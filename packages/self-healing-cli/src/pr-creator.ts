/**
 * PR Creator Module
 * Creates a pull request with the fixes
 */

import { $ } from 'zx';

// Configure zx for quiet mode
$.verbose = false;

export interface PRResult {
  success: boolean;
  prUrl?: string;
  error?: string;
}

/**
 * Configure git user for commits
 */
async function configureGitUser(): Promise<void> {
  await $`git config user.name "github-actions[bot]"`;
  await $`git config user.email "github-actions[bot]@users.noreply.github.com"`;
}

/**
 * Create a fix branch and push changes
 */
export async function createFixPR(
  originalBranch: string,
  runId: string,
  commitMessage = 'fix: auto-fix CI errors',
): Promise<PRResult> {
  const fixBranch = `fix/self-healing-${runId}`;

  try {
    // Configure git user
    await configureGitUser();

    // Create and checkout fix branch
    await $`git checkout -b ${fixBranch}`;

    // Stage all changes
    await $`git add .`;

    // Check if there are changes to commit
    try {
      await $`git diff --staged --quiet`;
      // If we reach here, there are no changes
      return {
        success: false,
        error: 'No changes to commit',
      };
    } catch {
      // Changes exist, continue
    }

    // Commit changes
    const fullMessage = `${commitMessage}\n\nCo-Authored-By: GitHub Copilot <noreply@github.com>\n\nThis commit was automatically generated by self-healing CI.`;
    await $`git commit -m ${fullMessage}`;

    // Push the branch
    await $`git push origin ${fixBranch}`;

    // Create PR using gh CLI
    const prBody = `## ðŸ¤– Automated Fix

This PR contains automatic fixes generated by the self-healing CI system.

### What was fixed
- CI errors detected in the lint/format check
- Fixes applied using GitHub Copilot

### Review checklist
- [ ] Verify the fixes are correct
- [ ] Ensure no unintended changes were made
- [ ] Test locally if needed

---
*Generated by [@rspress/self-healing-cli](https://github.com/web-infra-dev/rspress)*`;

    const prResult = await $`gh pr create \
      --title "fix: auto-fix CI errors" \
      --body ${prBody} \
      --base ${originalBranch} \
      --head ${fixBranch}`;

    // Extract PR URL from output
    const prUrl = prResult.stdout.trim();

    return {
      success: true,
      prUrl,
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);

    // Try to clean up the branch if something went wrong
    try {
      await $`git checkout ${originalBranch}`;
      await $`git branch -D ${fixBranch}`;
    } catch {
      // Ignore cleanup errors
    }

    return {
      success: false,
      error: `Failed to create PR: ${message}`,
    };
  }
}

/**
 * Check if we're in a valid git repository
 */
export async function isGitRepository(): Promise<boolean> {
  try {
    await $`git rev-parse --git-dir`;
    return true;
  } catch {
    return false;
  }
}

/**
 * Get the current branch name
 */
export async function getCurrentBranch(): Promise<string> {
  const result = await $`git rev-parse --abbrev-ref HEAD`;
  return result.stdout.trim();
}

/**
 * Check if gh CLI is available
 */
export async function isGhCliAvailable(): Promise<boolean> {
  try {
    await $`gh --version`;
    return true;
  } catch {
    return false;
  }
}
