# Static Site Generation (SSG)

## What is SSG

SSG (Static Site Generation) refers to pre-rendering pages into HTML files during the **build phase**, rather than rendering them when users visit.

Rspress enables SSG by default, which means when you run `rspress build`, each page will be pre-rendered into an HTML file containing complete content.

**Advantages of SSG:**

- **Faster First Contentful Paint**: Users don't need to wait for JavaScript to load and execute; they see complete content as soon as the browser loads the HTML
- **SEO Friendly**: Search engine crawlers can directly access complete HTML content
- **Easy to Deploy**: Output consists of pure static files that can be deployed to any static hosting service

## Dev Uses CSR, Build Uses SSG or CSR

| Aspect        | Dev Mode                         | Build Mode                             |
| ------------- | -------------------------------- | -------------------------------------- |
| Command       | `rspress dev`                    | `rspress build`                        |
| Rendering     | Pure CSR (Client-Side Rendering) | SSG (default) or CSR                   |
| Pre-rendering | None                             | Pre-renders all pages when SSG enabled |
| Use Case      | Development, debugging, HMR      | Production deployment                  |

### Dev Mode

```bash
rspress dev
```

Dev mode uses **pure Client-Side Rendering (CSR)** without pre-rendering. This is to provide a faster development experience and hot module replacement capability.

:::tip
If your code works fine in Dev mode but throws errors in Build mode, it's usually because SSG renders in a Node.js environment and cannot access browser APIs (like `window` or `document`). See "Common Issues and Solutions" below.
:::

### Build Mode

```bash
rspress build
```

Build mode enables SSG by default and generates pre-rendered HTML files for each page. You can control the output type through the `ssg` configuration.

**After building:**

- **Local Preview**: Use `rspress preview` to start a local static server for previewing the output

  ```bash
  rspress preview
  ```

- **Server Deployment**: Deploy the `doc_build` directory to static hosting services (GitHub Pages, Netlify, Vercel, etc.)

## SSG vs CSR Output

### Output Directory Structure

Whether using SSG or CSR mode, the output directory structure is the same:

```bash
doc_build/
├── static/
│   ├── js/
│   │   ├── main.[hash].js
│   │   └── async/
│   └── css/
│       └── main.[hash].css
├── index.html
├── guide/
│   └── getting-started.html
└── api/
    └── config.html
```

### HTML Content Differences

The core difference between the two modes lies in the HTML file content:

**SSG Output HTML** (contains pre-rendered complete page content):

```html
<body>
  <div id="root">
    <!-- Pre-rendered complete page content -->
    <nav>...</nav>
    <main>
      <article>
        <h1>Getting Started</h1>
        <p>Welcome to Rspress...</p>
      </article>
    </main>
  </div>
  <script src="/static/js/main.xxx.js"></script>
</body>
```

**CSR Output HTML** (only empty container, waiting for JS to render):

```html
<body>
  <div id="root"></div>
  <script src="/static/js/main.xxx.js"></script>
</body>
```

### Loading Flow Differences

**SSG Loading Flow:**

1. Browser loads HTML → User **immediately sees complete content**
2. JavaScript finishes loading → React hydrates, binds event interactions
3. Subsequent navigation → SPA mode, client-side rendering

**CSR Loading Flow:**

1. Browser loads HTML → User sees **blank page**
2. JavaScript finishes loading → React renders page content
3. Subsequent navigation → SPA mode, client-side rendering

## Common Issues and Solutions

### `window is not defined` / `document is not defined`

**Cause**: SSG renders pages in a Node.js environment, where browser-specific global objects like `window` and `document` don't exist.

**Solutions**:

1. **Use `useEffect` for delayed execution**: Place browser API calls inside `useEffect` to ensure they only run on the client

   ```tsx
   import { useEffect, useState } from 'react';

   function MyComponent() {
     const [width, setWidth] = useState(0);

     useEffect(() => {
       // Only runs on client
       setWidth(window.innerWidth);
     }, []);

     return <div>Window width: {width}</div>;
   }
   ```

2. **Conditional check**: Check the environment before accessing browser APIs

   ```tsx
   if (typeof window !== 'undefined') {
     // Browser environment
     console.log(window.location.href);
   }
   ```

3. **Dynamic import**: For third-party libraries that depend on browser APIs, use dynamic imports

   ```tsx
   import { useEffect, useState } from 'react';

   function MyComponent() {
     const [Editor, setEditor] = useState(null);

     useEffect(() => {
       import('some-browser-only-library').then((mod) => {
         setEditor(() => mod.default);
       });
     }, []);

     if (!Editor) return <div>Loading...</div>;
     return <Editor />;
   }
   ```

### Hydration Mismatch

**Cause**: The server-rendered HTML content doesn't match the client's first render. React checks for consistency during hydration, and mismatches will cause warnings or errors.

**Common scenarios**:

- Using `Date.now()` or random numbers
- Rendering different content based on `window` object properties (like `window.innerWidth`)
- Using data that only exists on the client (like localStorage)

**Solution**: Ensure the first render output is consistent between server and client. For content that needs to change dynamically on the client, use `useEffect` to update after hydration completes.

```tsx
import { useEffect, useState } from 'react';

function MyComponent() {
  // First render uses default value for server/client consistency
  const [theme, setTheme] = useState('light');

  useEffect(() => {
    // Read localStorage after hydration completes
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme) {
      setTheme(savedTheme);
    }
  }, []);

  return <div className={theme}>...</div>;
}
```

## Configuration

You can control whether SSG is enabled through the `ssg` configuration:

```ts title="rspress.config.ts"
import { defineConfig } from '@rspress/core';

export default defineConfig({
  ssg: true, // Default value, SSG enabled
});
```

If your site has special requirements, you can disable SSG:

```ts title="rspress.config.ts"
import { defineConfig } from '@rspress/core';

export default defineConfig({
  ssg: false, // Disable SSG, use CSR
});
```

:::warning
Please be cautious when disabling SSG, as this will forfeit the advantages of faster first contentful paint and SEO benefits.
:::

## Custom HTML Content

Through `builderConfig.html.tags`, you can inject custom content into HTML, such as adding analytics code, scripts, or styles:

```ts title="rspress.config.ts"
import { defineConfig } from '@rspress/core';

export default defineConfig({
  builderConfig: {
    html: {
      tags: [
        {
          tag: 'script',
          attrs: {
            src: 'https://cdn.example.com/analytics.js',
          },
        },
      ],
    },
  },
});
```

For more configuration details, please refer to the [Rsbuild html.tags documentation](https://rsbuild.dev/config/html/tags).
